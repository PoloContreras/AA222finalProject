import tensorflow as tf
import numpy as np
from aa222_finalproject_regression import BuildModel, evaluateModelDesign, datasetLoad
from random import randint

#We already know the size of the first and last layer n
#We specify the MAX amount of layers we want but Hooke-Jeeves can vary that if it wants

#INPUTS
max_layers = 3

#I want to be able to access the input :()
input_neurons = 28
output_neurons = 2

#Hooking and Jeeving
alpha = 10
a = np.array([randint(0, 3) for p in range(0, max_layers)])
a[0] = input_neurons
a[1] = randint(1, 3)
a[max_layers-1] = output_neurons
#After the first zero make every next value also 0 except for the last one
idx = np.array(np.where(a == 0))
for i in range(len(a)):
    if idx[0] + i == len(a) -1:
        break
    a[idx[0] + i] = 0

a_best = a
x, y, xtest, ytest = datasetLoad()
model = BuildModel(a, output_dim=2, activation_function='relu')
best_score = evaluateModelDesign(model, a, x, y, xtest, ytest, save=False, training_epochs=10)

# #Then we start the loop
while alpha > 1:
    improved = False

    #CHECK THE ENTIRE VECTOR
    for i in range(1, len(a)-1): #The range specifically does not change the first or the last value
        if a[i] < alpha:
            a[i] += alpha
            model = BuildModel(a, output_dim=2, activation_function='relu')
            score = evaluateModelDesign(model, a, x, y, xtest, ytest, save=False, training_epochs=10)
            if score < best_score:
                a_best = a
                improved = True

            #Return to the a value
            a[i] -= alpha

        elif a[i] >= alpha:
            #Upper Branch
            a[i] += alpha
            model = BuildModel(a, output_dim=2, activation_function='relu')
            score = evaluateModelDesign(model, a, x, y, xtest, ytest, save=False, training_epochs=10)
            if score < best_score:
                a_best = a
                improved = True

            #Lower Branch
            a[i] -= 2*alpha
            model = BuildModel(a, output_dim=2, activation_function='relu')
            score = evaluateModelDesign(model, a, x, y, xtest, ytest, save=False, training_epochs=10)
            if score < best_score:
                a_best = a
                improved = True
            
            #Return to the a value
            a[i] += alpha
    
    if improved == False:
        alpha = 0.5*alpha
        if alpha >= 1:
            alpha = round(alpha)
        else:
            break
    else:
        a = a_best

print(a)

# #return a

    
        






